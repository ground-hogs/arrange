{"version":3,"file":"index.modern.mjs","sources":["../src/parsers/json.ts","../src/util/mergeDeep.ts","../src/index.ts","../src/parsers/js.ts"],"sourcesContent":["import { ConfigParser } from \"../index\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { existsSync } from \"fs\";\r\nimport { readFile } from \"fs/promises\";\r\n\r\nconst { parse } = JSON;\r\n\r\nexport const ext = \"json\";\r\n\r\nexport const parser: ConfigParser = async (path) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  if (!existsSync(path)) {\r\n    throw new Error(`Config file not found in ${path}`);\r\n  } else {\r\n    try {\r\n      const contents = await readFile(path, \"utf-8\");\r\n      return parse(contents);\r\n    } catch (cantParse) {\r\n      if (cantParse instanceof Error) {\r\n        switch (true) {\r\n          case (cantParse.message as string).includes(\"JSON\"):\r\n            throw new RangeError(`JSON in \"${path}\" is invalid`);\r\n            break;\r\n          default:\r\n            throw new RangeError(`Can't read JSON config from \"${path}\"`);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","type Extendable = boolean | Array<unknown> | Record<string, unknown>;\r\ntype Extendables = Array<Extendable>;\r\n\r\n/**\r\n * @typedef {boolean | Array<unknown> | Record<string, unknown>} Extendable\r\n */\r\n\r\n/**\r\n * @typedef {Array<Extendable>} Extendables\r\n */\r\n\r\n/**\r\n * Yanked from JQuery.\r\n * @see https://gist.github.com/cfv1984/6319681685f78333d98a\r\n * @param {Extendables}\r\n * @returns Record\r\n */\r\nexport default function mergeDeep<NergeResult = unknown>(\r\n  this: any,\r\n  ..._: Extendables\r\n): NergeResult {\r\n  function isFunction(fn: unknown) {\r\n    return typeof fn === \"function\" && fn.constructor === Function;\r\n  }\r\n  function isArray(ar: unknown) {\r\n    return ar instanceof Array;\r\n  }\r\n  function isPlainObject(obj: unknown) {\r\n    return (\r\n      obj !== null &&\r\n      typeof obj == \"object\" &&\r\n      \"constructor\" in (obj as object) &&\r\n      obj.constructor == Object\r\n    );\r\n  }\r\n\r\n  let options: unknown;\r\n  let src: unknown;\r\n  let copy: unknown;\r\n  let copyIsArray = false;\r\n  let clone: unknown;\r\n  let target = arguments[0] || {};\r\n  let i = 1;\r\n  let deep = false;\r\n  const length = arguments.length;\r\n\r\n  if (typeof target === \"boolean\") {\r\n    deep = target;\r\n    target = arguments[i] || {};\r\n    i++;\r\n  }\r\n  if (typeof target !== \"object\" && !isFunction(target)) target = {};\r\n  if (i === length) {\r\n    target = this as any;\r\n    i--;\r\n  }\r\n  for (; i < length; i++) {\r\n    if ((options = arguments[i]) != null) {\r\n      for (const name in options) {\r\n        src = target[name];\r\n        copy = options[name as keyof typeof options];\r\n        if (target === copy) continue;\r\n\r\n        if (\r\n          deep &&\r\n          copy &&\r\n          (isPlainObject(copy) || (copyIsArray = isArray(copy)))\r\n        ) {\r\n          if (!copyIsArray) {\r\n            copyIsArray = false;\r\n            clone = src && isArray(src) ? src : [];\r\n          } else clone = src && isPlainObject(src) ? src : {};\r\n\r\n          target[name] = mergeDeep(\r\n            deep,\r\n            clone as Extendable,\r\n            copy as Extendable\r\n          );\r\n        } else if (copy !== undefined) target[name] = copy;\r\n      }\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","/**\r\n * @usage:\r\n * const config = await arrange(\"./path/to/config/file.ext\");\r\n * // or\r\n * const config = await arrange([\r\n * \"./path/to/config/file.ext\",\r\n *  [ \"js\", YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n * // or\r\n * const config = await arrange(\r\n * \"./path/to/config/file.ext\",\r\n * [\r\n *  [ [\"js\",\"mjs\"], YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n */\r\n\r\nimport { notEqual, match } from \"assert\";\r\nimport * as JSON_PARSER from \"./parsers/json\";\r\nimport * as JS_CONFIG_PARSER from \"./parsers/js\";\r\nimport mergeDeep from \"./util/mergeDeep\";\r\nexport type ConfigParser = (path: string) => Promise<Config>;\r\ntype ConfigValueType = Date | number | string | boolean;\r\ntype Config = Record<string, ConfigValueType>;\r\ntype ExtOrExts = string | Array<string>;\r\ntype ConfigParserEntry = [ExtOrExts, ConfigParser];\r\ntype ConfigParsers = Array<ConfigParserEntry>;\r\n\r\nconst DEFAULT_ARRANGE_PARSERS: NonNullable<ConfigParsers> = [\r\n  [JSON_PARSER.ext, JSON_PARSER.parser],\r\n  [JS_CONFIG_PARSER.ext, JS_CONFIG_PARSER.parser],\r\n];\r\ntype ParserMap = Map<string, ConfigParser>;\r\n\r\nexport async function arrange<ExpectedAttributes extends Config>(\r\n  path: string,\r\n  parsers?: ConfigParsers\r\n): Promise<Partial<ExpectedAttributes>> {\r\n  notEqual(path, undefined, \"Path can't be undefined\");\r\n  notEqual(path, null, \"Path can't be null\");\r\n  notEqual(path, \"\", \"Path can't be empty\");\r\n  match(path, /.?\\..?/, \"Path needs to have SOME extension\");\r\n\r\n  const loadedParsers: ParserMap = new Map();\r\n  for (const [ext, parser] of DEFAULT_ARRANGE_PARSERS) {\r\n    attachToMap(ext, parser, loadedParsers);\r\n  }\r\n  if (parsers) {\r\n    for (const [ext, parser] of parsers) {\r\n      attachToMap(ext, parser, loadedParsers);\r\n    }\r\n  }\r\n  const ext = path.split(\".\").at(-1);\r\n\r\n  if (ext && loadedParsers.has(ext)) {\r\n    const parser = loadedParsers.get(ext) as ConfigParser;\r\n    return (await parser(path)) as Partial<ExpectedAttributes>;\r\n  } else {\r\n    throw new RangeError(`Unknown config file type: ${ext}`);\r\n  }\r\n}\r\n\r\nexport async function arrangeMany(\r\n  paths: Array<string>,\r\n  parsers?: ConfigParsers\r\n) {\r\n  const results = await Promise.all(\r\n    paths.map((path) => arrange(path, parsers))\r\n  );\r\n  return mergeDeep(...results);\r\n}\r\n\r\nfunction attachToMap(\r\n  ext: ExtOrExts,\r\n  parser: ConfigParser,\r\n  map: Map<string, ConfigParser>\r\n) {\r\n  if (Array.isArray(ext)) {\r\n    ext.forEach((e) => map.set(e, parser));\r\n  } else {\r\n    map.set(ext, parser);\r\n  }\r\n}\r\n","import { createRequire } from \"module\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { ConfigParser } from \"../index\";\r\nimport { existsSync } from \"fs\";\r\n\r\nexport const ext = [\"js\", \"mjs\"];\r\n\r\ntype ConfigReturn = ReturnType<ConfigParser>;\r\n\r\nexport const parser: ConfigParser = async (path: string) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  const doRequire = createRequire(import.meta.url);\r\n  const contents = doRequire(path);\r\n\r\n  if (contents instanceof Function) {\r\n    return contents() as ConfigReturn;\r\n  }\r\n  return contents as ConfigReturn;\r\n};\r\n"],"names":["parse","JSON","mergeDeep","_","isArray","ar","Array","isPlainObject","obj","constructor","Object","options","src","copy","clone","copyIsArray","target","arguments","i","deep","length","fn","Function","this","name","undefined","DEFAULT_ARRANGE_PARSERS","async","isAbsolute","path","resolve","process","cwd","existsSync","Error","contents","readFile","cantParse","message","includes","RangeError","createRequire","url","doRequire","arrange","parsers","notEqual","match","loadedParsers","Map","ext","parser","attachToMap","split","at","has","get","arrangeMany","paths","Promise","all","map","forEach","e","set"],"mappings":"0MAKA,MAAMA,MAAEA,GAAUC,cCYMC,KAEnBC,GAKH,SAASC,EAAQC,GACf,OAAOA,aAAcC,KACvB,CACA,SAASC,EAAcC,GACrB,OACU,OAARA,GACc,iBAAPA,GACP,gBAAkBA,GAClBA,EAAIC,aAAeC,MAEvB,CAEA,IAAIC,EACAC,EACAC,EAEAC,EADAC,GAAc,EAEdC,EAASC,UAAU,IAAM,GACzBC,EAAI,EACJC,GAAO,EACX,MAAMC,EAASH,UAAUG,OAvBzB,IAAoBC,EAmCpB,IAVsB,kBAAXL,IACTG,EAAOH,EACPA,EAASC,UAAUC,IAAM,GACzBA,KAEoB,iBAAXF,IA7BY,mBADHK,EA8B0BL,IA7BTK,EAAGZ,cAAgBa,YA6BDN,EAAS,IAC5DE,IAAME,IACRJ,EAASO,KACTL,KAEKA,EAAIE,EAAQF,IACjB,GAAgC,OAA3BP,EAAUM,UAAUC,IACvB,IAAK,MAAMM,KAAQb,EACjBC,EAAMI,EAAOQ,GACbX,EAAOF,EAAQa,GACXR,IAAWH,IAGbM,GACAN,IACCN,EAAcM,KAAUE,EAAcX,EAAQS,MAE1CE,EAGED,EAAQF,GAAOL,EAAcK,GAAOA,EAAM,CAAA,GAF/CG,GAAc,EACdD,EAAQF,GAAOR,EAAQQ,GAAOA,EAAM,IAGtCI,EAAOQ,GAAQtB,EACbiB,EACAL,EACAD,SAEgBY,IAATZ,IAAoBG,EAAOQ,GAAQX,IAKpD,OAAOG,CACT,CCzDA,MAAMU,EAAsD,CAC1D,CFrBiB,OAEiBC,UAIlC,GAHKC,EAAWC,KACdA,EAAOC,EAAQC,QAAQC,MAAOH,KAE3BI,EAAWJ,GACd,MAAU,IAAAK,kCAAkCL,KAE5C,IACE,MAAMM,QAAiBC,EAASP,EAAM,SACtC,OAAO7B,EAAMmC,EACd,CAAC,MAAOE,GACP,GAAIA,aAAqBH,MAAO,CAC9B,IAAQ,IACAG,EAAUC,QAAmBC,SAAS,QAC1C,UAAUC,uBAAuBX,iBAGjC,MAAM,IAAIW,2CAA2CX,KAG1D,CACF,CACF,GEFD,CCxBiB,CAAC,KAAM,OAIUF,UAC7BC,EAAWC,KACdA,EAAOC,EAAQC,QAAQC,MAAOH,IAEhC,MACMM,EADYM,cAA0BC,IAC3BC,CAAUd,GAE3B,OAAIM,aAAoBb,SACfa,IAEFA,KDcaR,eAAAiB,EACpBf,EACAgB,GAEAC,EAASjB,OAAMJ,EAAW,2BAC1BqB,EAASjB,EAAM,KAAM,sBACrBiB,EAASjB,EAAM,GAAI,uBACnBkB,EAAMlB,EAAM,SAAU,qCAEtB,MAAMmB,EAA2B,IAAIC,IACrC,IAAK,MAAOC,EAAKC,KAAWzB,EAC1B0B,EAAYF,EAAKC,EAAQH,GAE3B,GAAIH,EACF,IAAK,MAAOK,EAAKC,KAAWN,EAC1BO,EAAYF,EAAKC,EAAQH,GAG7B,MAAME,EAAMrB,EAAKwB,MAAM,KAAKC,IAAI,GAEhC,GAAIJ,GAAOF,EAAcO,IAAIL,GAAM,CACjC,MAAMC,EAASH,EAAcQ,IAAIN,GACjC,aAAcC,EAAOtB,EACtB,CACC,MAAU,IAAAW,wCAAwCU,IAEtD,gBAEsBO,EACpBC,EACAb,GAKA,OAAO3C,WAHeyD,QAAQC,IAC5BF,EAAMG,IAAKhC,GAASe,EAAQf,EAAMgB,KAGtC,CAEA,SAASO,EACPF,EACAC,EACAU,GAEIvD,MAAMF,QAAQ8C,GAChBA,EAAIY,QAASC,GAAMF,EAAIG,IAAID,EAAGZ,IAE9BU,EAAIG,IAAId,EAAKC,EAEjB"}