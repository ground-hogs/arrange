{"version":3,"file":"index.umd.js","sources":["../src/parsers/json.ts","../src/util/mergeDeep.ts","../src/index.ts","../src/parsers/js.ts"],"sourcesContent":["import { ConfigParser } from \"../index\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { existsSync } from \"fs\";\r\nimport { readFile } from \"fs/promises\";\r\n\r\nconst { parse } = JSON;\r\n\r\nexport const ext = \"json\";\r\n\r\nexport const parser: ConfigParser = async (path) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  if (!existsSync(path)) {\r\n    throw new Error(`Config file not found in ${path}`);\r\n  } else {\r\n    try {\r\n      const contents = await readFile(path, \"utf-8\");\r\n      return parse(contents);\r\n    } catch (cantParse) {\r\n      if (cantParse instanceof Error) {\r\n        switch (true) {\r\n          case (cantParse.message as string).includes(\"JSON\"):\r\n            throw new RangeError(`JSON in \"${path}\" is invalid`);\r\n            break;\r\n          default:\r\n            throw new RangeError(`Can't read JSON config from \"${path}\"`);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","type Extendable = boolean | Array<unknown> | Record<string, unknown>;\r\ntype Extendables = Array<Extendable>;\r\n\r\n/**\r\n * @typedef {boolean | Array<unknown> | Record<string, unknown>} Extendable\r\n */\r\n\r\n/**\r\n * @typedef {Array<Extendable>} Extendables\r\n */\r\n\r\n/**\r\n * Yanked from JQuery.\r\n * @see https://gist.github.com/cfv1984/6319681685f78333d98a\r\n * @param {Extendables}\r\n * @returns Record\r\n */\r\nexport default function mergeDeep<NergeResult = unknown>(\r\n  this: any,\r\n  ..._: Extendables\r\n): NergeResult {\r\n  function isFunction(fn: unknown) {\r\n    return typeof fn === \"function\" && fn.constructor === Function;\r\n  }\r\n  function isArray(ar: unknown) {\r\n    return ar instanceof Array;\r\n  }\r\n  function isPlainObject(obj: unknown) {\r\n    return (\r\n      obj !== null &&\r\n      typeof obj == \"object\" &&\r\n      \"constructor\" in (obj as object) &&\r\n      obj.constructor == Object\r\n    );\r\n  }\r\n\r\n  let options: unknown;\r\n  let src: unknown;\r\n  let copy: unknown;\r\n  let copyIsArray = false;\r\n  let clone: unknown;\r\n  let target = arguments[0] || {};\r\n  let i = 1;\r\n  let deep = false;\r\n  const length = arguments.length;\r\n\r\n  if (typeof target === \"boolean\") {\r\n    deep = target;\r\n    target = arguments[i] || {};\r\n    i++;\r\n  }\r\n  if (typeof target !== \"object\" && !isFunction(target)) target = {};\r\n  if (i === length) {\r\n    target = this as any;\r\n    i--;\r\n  }\r\n  for (; i < length; i++) {\r\n    if ((options = arguments[i]) != null) {\r\n      for (const name in options) {\r\n        src = target[name];\r\n        copy = options[name as keyof typeof options];\r\n        if (target === copy) continue;\r\n\r\n        if (\r\n          deep &&\r\n          copy &&\r\n          (isPlainObject(copy) || (copyIsArray = isArray(copy)))\r\n        ) {\r\n          if (!copyIsArray) {\r\n            copyIsArray = false;\r\n            clone = src && isArray(src) ? src : [];\r\n          } else clone = src && isPlainObject(src) ? src : {};\r\n\r\n          target[name] = mergeDeep(\r\n            deep,\r\n            clone as Extendable,\r\n            copy as Extendable\r\n          );\r\n        } else if (copy !== undefined) target[name] = copy;\r\n      }\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","/**\r\n * @usage:\r\n * const config = await arrange(\"./path/to/config/file.ext\");\r\n * // or\r\n * const config = await arrange([\r\n * \"./path/to/config/file.ext\",\r\n *  [ \"js\", YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n * // or\r\n * const config = await arrange(\r\n * \"./path/to/config/file.ext\",\r\n * [\r\n *  [ [\"js\",\"mjs\"], YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n */\r\n\r\nimport { notEqual, match } from \"assert\";\r\nimport * as JSON_PARSER from \"./parsers/json\";\r\nimport * as JS_CONFIG_PARSER from \"./parsers/js\";\r\nimport mergeDeep from \"./util/mergeDeep\";\r\nexport type ConfigParser = (path: string) => Promise<Config>;\r\ntype ConfigValueType = Date | number | string | boolean;\r\ntype Config = Record<string, ConfigValueType>;\r\ntype ExtOrExts = string | Array<string>;\r\ntype ConfigParserEntry = [ExtOrExts, ConfigParser];\r\ntype ConfigParsers = Array<ConfigParserEntry>;\r\n\r\nconst DEFAULT_ARRANGE_PARSERS: NonNullable<ConfigParsers> = [\r\n  [JSON_PARSER.ext, JSON_PARSER.parser],\r\n  [JS_CONFIG_PARSER.ext, JS_CONFIG_PARSER.parser],\r\n];\r\ntype ParserMap = Map<string, ConfigParser>;\r\n\r\nexport async function arrange<ExpectedAttributes extends Config>(\r\n  path: string,\r\n  parsers?: ConfigParsers\r\n): Promise<Partial<ExpectedAttributes>> {\r\n  notEqual(path, undefined, \"Path can't be undefined\");\r\n  notEqual(path, null, \"Path can't be null\");\r\n  notEqual(path, \"\", \"Path can't be empty\");\r\n  match(path, /.?\\..?/, \"Path needs to have SOME extension\");\r\n\r\n  const loadedParsers: ParserMap = new Map();\r\n  for (const [ext, parser] of DEFAULT_ARRANGE_PARSERS) {\r\n    attachToMap(ext, parser, loadedParsers);\r\n  }\r\n  if (parsers) {\r\n    for (const [ext, parser] of parsers) {\r\n      attachToMap(ext, parser, loadedParsers);\r\n    }\r\n  }\r\n  const ext = path.split(\".\").at(-1);\r\n\r\n  if (ext && loadedParsers.has(ext)) {\r\n    const parser = loadedParsers.get(ext) as ConfigParser;\r\n    return (await parser(path)) as Partial<ExpectedAttributes>;\r\n  } else {\r\n    throw new RangeError(`Unknown config file type: ${ext}`);\r\n  }\r\n}\r\n\r\nexport async function arrangeMany(\r\n  paths: Array<string>,\r\n  parsers?: ConfigParsers\r\n) {\r\n  const results = await Promise.all(\r\n    paths.map((path) => arrange(path, parsers))\r\n  );\r\n  return mergeDeep(...results);\r\n}\r\n\r\nfunction attachToMap(\r\n  ext: ExtOrExts,\r\n  parser: ConfigParser,\r\n  map: Map<string, ConfigParser>\r\n) {\r\n  if (Array.isArray(ext)) {\r\n    ext.forEach((e) => map.set(e, parser));\r\n  } else {\r\n    map.set(ext, parser);\r\n  }\r\n}\r\n","import { createRequire } from \"module\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { ConfigParser } from \"../index\";\r\nimport { existsSync } from \"fs\";\r\n\r\nexport const ext = [\"js\", \"mjs\"];\r\n\r\ntype ConfigReturn = ReturnType<ConfigParser>;\r\n\r\nexport const parser: ConfigParser = async (path: string) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  const doRequire = createRequire(import.meta.url);\r\n  const contents = doRequire(path);\r\n\r\n  if (contents instanceof Function) {\r\n    return contents() as ConfigReturn;\r\n  }\r\n  return contents as ConfigReturn;\r\n};\r\n"],"names":["parse","JSON","mergeDeep","isArray","ar","Array","isPlainObject","obj","constructor","Object","options","src","copy","clone","fn","copyIsArray","target","arguments","i","deep","length","Function","this","name","undefined","arrange","path","parsers","notEqual","match","_step","loadedParsers","Map","_iterator","_createForOfIteratorHelperLoose","DEFAULT_ARRANGE_PARSERS","done","_step$value","value","attachToMap","parser","_step2","_iterator2","_step2$value","ext","split","at","has","get","Promise","resolve","RangeError","e","reject","isAbsolute","process","cwd","existsSync","readFile","then","_catch","cantParse","Error","message","includes","contents","createRequire","import","doRequire","map","forEach","set","paths","all","results","apply"],"mappings":"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"}