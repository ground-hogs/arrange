import{notEqual as n,match as t}from"assert";import{isAbsolute as o,resolve as r}from"path";import{existsSync as e}from"fs";import{readFile as c}from"fs/promises";import{createRequire as i}from"module";const{parse:s}=JSON;function a(...n){function t(n){return n instanceof Array}function o(n){return null!==n&&"object"==typeof n&&"constructor"in n&&n.constructor==Object}let r,e,c,i,s=!1,f=arguments[0]||{},u=1,p=!1;const l=arguments.length;var m;for("boolean"==typeof f&&(p=f,f=arguments[u]||{},u++),"object"!=typeof f&&("function"!=typeof(m=f)||m.constructor!==Function)&&(f={}),u===l&&(f=this,u--);u<l;u++)if(null!=(r=arguments[u]))for(const n in r)e=f[n],c=r[n],f!==c&&(p&&c&&(o(c)||(s=t(c)))?(s?i=e&&o(e)?e:{}:(s=!1,i=e&&t(e)?e:[]),f[n]=a(p,i,c)):void 0!==c&&(f[n]=c));return f}const f=[["json",async n=>{if(o(n)||(n=r(process.cwd(),n)),!e(n))throw new Error(`Config file not found in ${n}`);try{const t=await c(n,"utf-8");return s(t)}catch(t){if(t instanceof Error){if(!0===t.message.includes("JSON"))throw new RangeError(`JSON in "${n}" is invalid`);throw new RangeError(`Can't read JSON config from "${n}"`)}}}],[["js","mjs"],async n=>{o(n)||(n=r(process.cwd(),n));const t=i(import.meta.url)(n);return t instanceof Function?t():t}]];async function u(o,r){n(o,void 0,"Path can't be undefined"),n(o,null,"Path can't be null"),n(o,"","Path can't be empty"),t(o,/.?\..?/,"Path needs to have SOME extension");const e=new Map;for(const[n,t]of f)l(n,t,e);if(r)for(const[n,t]of r)l(n,t,e);const c=o.split(".").at(-1);if(c&&e.has(c)){const n=e.get(c);return await n(o)}throw new RangeError(`Unknown config file type: ${c}`)}async function p(n,t){return a(...await Promise.all(n.map(n=>u(n,t))))}function l(n,t,o){Array.isArray(n)?n.forEach(n=>o.set(n,t)):o.set(n,t)}export{u as arrange,p as arrangeMany};
//# sourceMappingURL=index.modern.mjs.map
