{"version":3,"file":"index.js","sources":["../src/parsers/json.ts","../src/parsers/js.ts","../src/index.ts"],"sourcesContent":["import { ConfigParser } from \"../index\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { existsSync } from \"fs\";\r\nimport { readFile } from \"fs/promises\";\r\n\r\nconst { parse } = JSON;\r\n\r\nexport const ext = \"json\";\r\n\r\nexport const parser: ConfigParser = async (path) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  if (!existsSync(path)) {\r\n    throw new Error(`Config file not found in ${path}`);\r\n  } else {\r\n    try {\r\n      const contents = await readFile(path, \"utf-8\");\r\n      return parse(contents);\r\n    } catch (cantParse) {\r\n      if (cantParse instanceof Error) {\r\n        switch (true) {\r\n          case (cantParse.message as string).includes(\"JSON\"):\r\n            throw new RangeError(`JSON in \"${path}\" is invalid`);\r\n            break;\r\n          default:\r\n            throw new RangeError(`Can't read JSON config from \"${path}\"`);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","import { createRequire } from \"module\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { ConfigParser } from \"../index\";\r\nimport { existsSync } from \"fs\";\r\n\r\nexport const ext = [\"js\", \"mjs\"];\r\n\r\ntype ConfigReturn = ReturnType<ConfigParser>;\r\n\r\nexport const parser: ConfigParser = async (path: string) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  const doRequire = createRequire(import.meta.url);\r\n  const contents = doRequire(path);\r\n\r\n  if (contents instanceof Function) {\r\n    return contents() as ConfigReturn;\r\n  }\r\n  return contents as ConfigReturn;\r\n};\r\n","/**\r\n * @usage:\r\n * const config = await arrange(\"./path/to/config/file.ext\");\r\n * // or\r\n * const config = await arrange([\r\n * \"./path/to/config/file.ext\",\r\n *  [ \"js\", YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n * // or\r\n * const config = await arrange(\r\n * \"./path/to/config/file.ext\",\r\n * [\r\n *  [ [\"js\",\"mjs\"], YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n */\r\n\r\nimport { notEqual, match } from \"assert\";\r\nimport * as JSON_PARSER from \"./parsers/json\";\r\nimport * as JS_CONFIG_PARSER from \"./parsers/js\";\r\n\r\nexport type ConfigParser = (path: string) => Promise<Config>;\r\ntype ConfigValueType = Date | number | string | boolean;\r\ntype Config = Record<string, ConfigValueType>;\r\ntype ExtOrExts = string | Array<string>;\r\ntype ConfigParserEntry = [ExtOrExts, ConfigParser];\r\ntype ConfigParsers = Array<ConfigParserEntry>;\r\n\r\nconst DEFAULT_ARRANGE_PARSERS: NonNullable<ConfigParsers> = [\r\n  [JSON_PARSER.ext, JSON_PARSER.parser],\r\n  [JS_CONFIG_PARSER.ext, JS_CONFIG_PARSER.parser],\r\n];\r\ntype ParserMap = Map<string, ConfigParser>;\r\n\r\nexport default async function arrange<ExpectedAttributes extends Config>(\r\n  path: string,\r\n  parsers?: ConfigParsers\r\n): Promise<Partial<ExpectedAttributes>> {\r\n  notEqual(path, undefined, \"Path can't be undefined\");\r\n  notEqual(path, null, \"Path can't be null\");\r\n  notEqual(path, \"\", \"Path can't be empty\");\r\n  match(path, /.?\\..?/, \"Path needs to have SOME extension\");\r\n\r\n  const loadedParsers: ParserMap = new Map();\r\n  for (const [ext, parser] of DEFAULT_ARRANGE_PARSERS) {\r\n    attactToMap(ext, parser, loadedParsers);\r\n  }\r\n  if (parsers) {\r\n    for (const [ext, parser] of parsers) {\r\n      attactToMap(ext, parser, loadedParsers);\r\n    }\r\n  }\r\n  const ext = path.split(\".\").at(-1);\r\n\r\n  if (ext && loadedParsers.has(ext)) {\r\n    const parser = loadedParsers.get(ext) as ConfigParser;\r\n    return (await parser(path)) as Partial<ExpectedAttributes>;\r\n  } else {\r\n    throw new RangeError(`Unknown config file type: ${ext}`);\r\n  }\r\n}\r\n\r\nfunction attactToMap(\r\n  ext: ExtOrExts,\r\n  parser: ConfigParser,\r\n  map: Map<string, ConfigParser>\r\n) {\r\n  if (Array.isArray(ext)) {\r\n    ext.forEach((e) => map.set(e, parser));\r\n  } else {\r\n    map.set(ext, parser);\r\n  }\r\n}\r\n"],"names":["parse","JSON","ext","parser","path","isAbsolute","resolve","process","cwd","existsSync","Error","contents","readFile","cantParse","message","includes","RangeError","doRequire","createRequire","import","Function","DEFAULT_ARRANGE_PARSERS","JSON_PARSER","JS_CONFIG_PARSER","arrange","parsers","notEqual","undefined","match","loadedParsers","Map","attactToMap","split","at","has","get","map","Array","isArray","forEach","e","set"],"mappings":"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"}