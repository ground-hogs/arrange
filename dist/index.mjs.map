{"version":3,"file":"index.mjs","sources":["../src/parsers/json.ts","../src/util/mergeDeep.ts","../src/index.ts","../src/parsers/js.ts"],"sourcesContent":["import { ConfigParser } from \"../index\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { existsSync } from \"fs\";\r\nimport { readFile } from \"fs/promises\";\r\n\r\nconst { parse } = JSON;\r\n\r\nexport const ext = \"json\";\r\n\r\nexport const parser: ConfigParser = async (path) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  if (!existsSync(path)) {\r\n    throw new Error(`Config file not found in ${path}`);\r\n  } else {\r\n    try {\r\n      const contents = await readFile(path, \"utf-8\");\r\n      return parse(contents);\r\n    } catch (cantParse) {\r\n      if (cantParse instanceof Error) {\r\n        switch (true) {\r\n          case (cantParse.message as string).includes(\"JSON\"):\r\n            throw new RangeError(`JSON in \"${path}\" is invalid`);\r\n            break;\r\n          default:\r\n            throw new RangeError(`Can't read JSON config from \"${path}\"`);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n","type Extendable = boolean | Array<unknown> | Record<string, unknown>;\r\ntype Extendables = Array<Extendable>;\r\n\r\n/**\r\n * @typedef {boolean | Array<unknown> | Record<string, unknown>} Extendable\r\n */\r\n\r\n/**\r\n * @typedef {Array<Extendable>} Extendables\r\n */\r\n\r\n/**\r\n * Yanked from JQuery.\r\n * @see https://gist.github.com/cfv1984/6319681685f78333d98a\r\n * @param {Extendables}\r\n * @returns Record\r\n */\r\nexport default function mergeDeep<NergeResult = unknown>(\r\n  this: any,\r\n  ..._: Extendables\r\n): NergeResult {\r\n  function isFunction(fn: unknown) {\r\n    return typeof fn === \"function\" && fn.constructor === Function;\r\n  }\r\n  function isArray(ar: unknown) {\r\n    return ar instanceof Array;\r\n  }\r\n  function isPlainObject(obj: unknown) {\r\n    return (\r\n      obj !== null &&\r\n      typeof obj == \"object\" &&\r\n      \"constructor\" in (obj as object) &&\r\n      obj.constructor == Object\r\n    );\r\n  }\r\n\r\n  let options: unknown;\r\n  let src: unknown;\r\n  let copy: unknown;\r\n  let copyIsArray = false;\r\n  let clone: unknown;\r\n  let target = arguments[0] || {};\r\n  let i = 1;\r\n  let deep = false;\r\n  const length = arguments.length;\r\n\r\n  if (typeof target === \"boolean\") {\r\n    deep = target;\r\n    target = arguments[i] || {};\r\n    i++;\r\n  }\r\n  if (typeof target !== \"object\" && !isFunction(target)) target = {};\r\n  if (i === length) {\r\n    target = this as any;\r\n    i--;\r\n  }\r\n  for (; i < length; i++) {\r\n    if ((options = arguments[i]) != null) {\r\n      for (const name in options) {\r\n        src = target[name];\r\n        copy = options[name as keyof typeof options];\r\n        if (target === copy) continue;\r\n\r\n        if (\r\n          deep &&\r\n          copy &&\r\n          (isPlainObject(copy) || (copyIsArray = isArray(copy)))\r\n        ) {\r\n          if (!copyIsArray) {\r\n            copyIsArray = false;\r\n            clone = src && isArray(src) ? src : [];\r\n          } else clone = src && isPlainObject(src) ? src : {};\r\n\r\n          target[name] = mergeDeep(\r\n            deep,\r\n            clone as Extendable,\r\n            copy as Extendable\r\n          );\r\n        } else if (copy !== undefined) target[name] = copy;\r\n      }\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n","/**\r\n * @usage:\r\n * const config = await arrange(\"./path/to/config/file.ext\");\r\n * // or\r\n * const config = await arrange([\r\n * \"./path/to/config/file.ext\",\r\n *  [ \"js\", YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n * // or\r\n * const config = await arrange(\r\n * \"./path/to/config/file.ext\",\r\n * [\r\n *  [ [\"js\",\"mjs\"], YOUR_OWN_CONFIG_PARSER],\r\n * ]);\r\n */\r\n\r\nimport { notEqual, match } from \"assert\";\r\nimport * as JSON_PARSER from \"./parsers/json\";\r\nimport * as JS_CONFIG_PARSER from \"./parsers/js\";\r\nimport mergeDeep from \"./util/mergeDeep\";\r\nexport type ConfigParser = (path: string) => Promise<Config>;\r\ntype ConfigValueType = Date | number | string | boolean;\r\ntype Config = Record<string, ConfigValueType>;\r\ntype ExtOrExts = string | Array<string>;\r\ntype ConfigParserEntry = [ExtOrExts, ConfigParser];\r\ntype ConfigParsers = Array<ConfigParserEntry>;\r\n\r\nconst DEFAULT_ARRANGE_PARSERS: NonNullable<ConfigParsers> = [\r\n  [JSON_PARSER.ext, JSON_PARSER.parser],\r\n  [JS_CONFIG_PARSER.ext, JS_CONFIG_PARSER.parser],\r\n];\r\ntype ParserMap = Map<string, ConfigParser>;\r\n\r\nexport async function arrange<ExpectedAttributes extends Config>(\r\n  path: string,\r\n  parsers?: ConfigParsers\r\n): Promise<Partial<ExpectedAttributes>> {\r\n  notEqual(path, undefined, \"Path can't be undefined\");\r\n  notEqual(path, null, \"Path can't be null\");\r\n  notEqual(path, \"\", \"Path can't be empty\");\r\n  match(path, /.?\\..?/, \"Path needs to have SOME extension\");\r\n\r\n  const loadedParsers: ParserMap = new Map();\r\n  for (const [ext, parser] of DEFAULT_ARRANGE_PARSERS) {\r\n    attachToMap(ext, parser, loadedParsers);\r\n  }\r\n  if (parsers) {\r\n    for (const [ext, parser] of parsers) {\r\n      attachToMap(ext, parser, loadedParsers);\r\n    }\r\n  }\r\n  const ext = path.split(\".\").at(-1);\r\n\r\n  if (ext && loadedParsers.has(ext)) {\r\n    const parser = loadedParsers.get(ext) as ConfigParser;\r\n    return (await parser(path)) as Partial<ExpectedAttributes>;\r\n  } else {\r\n    throw new RangeError(`Unknown config file type: ${ext}`);\r\n  }\r\n}\r\n\r\nexport async function arrangeMany(\r\n  paths: Array<string>,\r\n  parsers?: ConfigParsers\r\n) {\r\n  const results = await Promise.all(\r\n    paths.map((path) => arrange(path, parsers))\r\n  );\r\n  return mergeDeep(...results);\r\n}\r\n\r\nfunction attachToMap(\r\n  ext: ExtOrExts,\r\n  parser: ConfigParser,\r\n  map: Map<string, ConfigParser>\r\n) {\r\n  if (Array.isArray(ext)) {\r\n    ext.forEach((e) => map.set(e, parser));\r\n  } else {\r\n    map.set(ext, parser);\r\n  }\r\n}\r\n","import { createRequire } from \"module\";\r\nimport { isAbsolute, resolve } from \"path\";\r\nimport { ConfigParser } from \"../index\";\r\nimport { existsSync } from \"fs\";\r\n\r\nexport const ext = [\"js\", \"mjs\"];\r\n\r\ntype ConfigReturn = ReturnType<ConfigParser>;\r\n\r\nexport const parser: ConfigParser = async (path: string) => {\r\n  if (!isAbsolute(path)) {\r\n    path = resolve(process.cwd(), path);\r\n  }\r\n  const doRequire = createRequire(import.meta.url);\r\n  const contents = doRequire(path);\r\n\r\n  if (contents instanceof Function) {\r\n    return contents() as ConfigReturn;\r\n  }\r\n  return contents as ConfigReturn;\r\n};\r\n"],"names":["parse","JSON","mergeDeep","isArray","ar","Array","isPlainObject","obj","constructor","Object","options","src","copy","clone","fn","copyIsArray","target","arguments","i","deep","length","Function","this","name","undefined","arrangeMany","paths","parsers","Promise","resolve","all","map","path","arrange","then","results","apply","e","reject","notEqual","match","_step","loadedParsers","Map","_iterator","_createForOfIteratorHelperLoose","DEFAULT_ARRANGE_PARSERS","done","_step$value","value","attachToMap","parser","_step2","_iterator2","_step2$value","ext","split","at","has","get","RangeError","isAbsolute","process","cwd","existsSync","readFile","_catch","cantParse","Error","message","includes","contents","createRequire","url","doRequire","forEach","set"],"mappings":"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"}